# redux-modern-crud

[![NPM version][npm-svg]][npm]
[![Build status][travis-svg]][travis]

[npm]: https://www.npmjs.com/package/redux-modern-crud
[npm-svg]: https://img.shields.io/npm/v/redux-modern-crud.svg?style=flat
[travis]: https://travis-ci.org/zugarzeeker/redux-modern-crud
[travis-svg]: https://img.shields.io/travis/zugarzeeker/redux-modern-crud.svg?style=flat


A library that helps you to manage `CRUD` for `Redux`.

This library was generated by `essay`(https://github.com/dtinth/essay).

## Getting started
  1. Install this library

  ```
  npm i --save redux-modern-crud
  ```

  2. import module from this library
  ```js
  import {
      utility,
      createActions,
      createReducer,
      createInteractor,
      mergeReducer
  } from 'redux-modern-crud'
  ```

## API
There are available modules that you can use.

```js
// main.js
import * as utility from './utility';
export { utility };
export { createActions } from './create-actions';
export { createReducer } from './create-reducer';
export { createInteractor } from './create-interactor';
export { mergeReducer } from './merge-reducer';
```

## Implementation
It shows inside this module how it works.

### Create Actions
`createActions` is a module that create three action types of `CRUD`.
- `REQUEST` starting request and waiting for response
- `SUCCESS` API respond status 200 and body
- `FAIL` API respond error with some reasons

```js
// create-actions.js
import { getActionTypes } from './utility';

export const createActions = (prefix, key) => {
  const [REQUEST, SUCCESS, FAIL] = getActionTypes(prefix, key);
  return { REQUEST, SUCCESS, FAIL };
};
```

### Create Reducer
`createReducer` is a module that create a pure function for handle `CRUD` state of `redux`.
It will call a specific entity follow action type that is similar switch case.
- Using `redux-actions` for create a simple reducer
- `createReducer` has callback functions options (e.g. use for handle access-token)

```js
// create-reducer.js
import { handleActions } from 'redux-actions';
import { handleWaiting, handleSuccess, handleFail, initState } from './entity';

const initialState = initState();
const initialAction = { type: 'init action' };
const defaultCallback = {
  callbackWaiting: () => {},
  callbackSuccess: () => {},
  callbackFail: () => {},
};

export const createReducer = (actions, multipleCallback) => {
  const { callbackWaiting, callbackSuccess, callbackFail } = {
    ...defaultCallback, ...multipleCallback
  };
  const { REQUEST, SUCCESS, FAIL } = actions;
  const reducer = handleActions({
    [REQUEST]: (state, action) => {
      callbackWaiting(state, action);
      return handleWaiting()(state);
    },
    [SUCCESS]: (state, action) => {
      callbackSuccess(state, action);
      return handleSuccess(action.result)(state);
    },
    [FAIL]: (state, action) => {
      callbackFail(state, action);
      return handleFail(action.error)(state);
    }
  }, initialState);
  return reducer;
};
```

### Entity
`entity` contains the core functions that handle about state.

```js
// entity.js
export const isInitialState = (state) => !state.request && !state.success;
export const isWaiting = (state) => state.waiting;
export const isSuccess = (state) => state.success && !!state.result;
export const isFailure = (state) => !!state.error;

export function initState() {
  return { waiting: false, success: false };
}

export const handleWaiting = () => (state) => ({
  ...state,
  waiting: true
});

export const handleSuccess = (result) => (state) => ({
  ...state,
  waiting: false,
  success: true,
  error: null,
  result
});

export const handleFail = (error) => (state) => ({
  ...state,
  waiting: false,
  success: false,
  error
});

```

### Testing
`entity.test` uses [circumstance](https://github.com/dtinth/circumstance)
to test the entities with `given`, `when`, and `then`.

```js
// entity.test.js
import { given, shouldEqual } from 'circumstance';
import * as CRUD from './entity';

describe('CRUD Entity', () => {
  it('should init state', () => {
    given(CRUD.initState())
    .then(CRUD.isInitialState, shouldEqual(true));
  });

  it('should handle waiting state', () => {
    given(CRUD.initState())
    .when(CRUD.handleWaiting())
    .then(CRUD.isWaiting, shouldEqual(true));
  });

  it('should handle success state', () => {
    given(CRUD.initState())
    .when(CRUD.handleSuccess('Operation Success'))
    .then(CRUD.isSuccess, shouldEqual(true));
  });

  it('should handle fail state', () => {
    given(CRUD.initState())
    .when(CRUD.handleFail('has some exceptions'))
    .then(CRUD.isFailure, shouldEqual(true));
  });
});
```

### Create Interactor
`createInteractor` can create a function that helps you to dispatch action with http request and return promise.

```js
// create-interactor.js
export const createInteractor = (actions) => {
  const { REQUEST, SUCCESS, FAIL } = actions;
  const formRequest = (method) => (url, { data, params } = {}) => ({
    types: [REQUEST, SUCCESS, FAIL],
    promise: (client) => client[method](url, { data, params })
  });
  const httpRequest = {};
  const methods = ['get', 'put', 'post', 'delete', 'patch'];
  methods.map((method) => {
    return httpRequest[method] = formRequest(method);
  });
  return httpRequest;
};
```

### Merge Reducer
`mergeReducer` merges all of them into one reducer. It selects action types by containing keyword.

`mergeReducer` is difference from `combineReducers` because
> `combineReducers` helps you to keep the same logical division between reducers.
> http://redux.js.org/docs/api/combineReducers.html

```js
// merge-reducer.js
import _ from 'lodash';
import { initState } from './entity';

const initialState = initState();
export const mergeReducer = (multiReducers) => {
  const reducer = (state = initialState, action = initialAction) => {
    const found = _.find(multiReducers, ({ word, reducer }) => {
      return action.type.indexOf(word) !== -1;
    });
    if (!!found) {
      return found.reducer(state, action);
    }
    return state;
  };
  return reducer;
};
```

### Utility
`addPrefix` generates a simple accessible action types of object that can be called by dot.
- e.g. UserActions.USER.LOGIN.SUCCESS

`getActionTypes` generates an array that contains three action types of `CRUD`.

```js
// utility.js
import _ from 'lodash';

export const addPrefix = (prefix, asyncKeys, syncKeys) => {
  return _.fromPairs(
    asyncKeys.map(asyncKey => {
      return [(asyncKey || []), {
        REQUEST: `${prefix}/${asyncKey}_REQUEST`,
        SUCCESS: `${prefix}/${asyncKey}_SUCCESS`,
        FAIL: `${prefix}/${asyncKey}_FAIL`
      }];
    }).concat((syncKeys || []).map(syncKey => {
      return [syncKey, `${prefix}/${syncKey}`];
    }))
  );
};

export const getActionTypes = (prefix, key) => {
  return [
    `${prefix}/${key}_REQUEST`,
    `${prefix}/${key}_SUCCESS`,
    `${prefix}/${key}_FAIL`
  ];
};
```
